// Code generated by counterfeiter. DO NOT EDIT.
package clientfakes

import (
	"context"
	"sync"
	"terraform-provider-panther/internal/client"
)

type FakeClient struct {
	CreateS3SourceStub        func(context.Context, client.CreateS3SourceInput) (client.CreateS3SourceOutput, error)
	createS3SourceMutex       sync.RWMutex
	createS3SourceArgsForCall []struct {
		arg1 context.Context
		arg2 client.CreateS3SourceInput
	}
	createS3SourceReturns struct {
		result1 client.CreateS3SourceOutput
		result2 error
	}
	createS3SourceReturnsOnCall map[int]struct {
		result1 client.CreateS3SourceOutput
		result2 error
	}
	DeleteSourceStub        func(context.Context, client.DeleteSourceInput) (client.DeleteSourceOutput, error)
	deleteSourceMutex       sync.RWMutex
	deleteSourceArgsForCall []struct {
		arg1 context.Context
		arg2 client.DeleteSourceInput
	}
	deleteSourceReturns struct {
		result1 client.DeleteSourceOutput
		result2 error
	}
	deleteSourceReturnsOnCall map[int]struct {
		result1 client.DeleteSourceOutput
		result2 error
	}
	GetS3SourceStub        func(context.Context, string) (*client.S3LogIntegration, error)
	getS3SourceMutex       sync.RWMutex
	getS3SourceArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getS3SourceReturns struct {
		result1 *client.S3LogIntegration
		result2 error
	}
	getS3SourceReturnsOnCall map[int]struct {
		result1 *client.S3LogIntegration
		result2 error
	}
	UpdateS3SourceStub        func(context.Context, client.UpdateS3SourceInput) (client.UpdateS3SourceOutput, error)
	updateS3SourceMutex       sync.RWMutex
	updateS3SourceArgsForCall []struct {
		arg1 context.Context
		arg2 client.UpdateS3SourceInput
	}
	updateS3SourceReturns struct {
		result1 client.UpdateS3SourceOutput
		result2 error
	}
	updateS3SourceReturnsOnCall map[int]struct {
		result1 client.UpdateS3SourceOutput
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) CreateS3Source(arg1 context.Context, arg2 client.CreateS3SourceInput) (client.CreateS3SourceOutput, error) {
	fake.createS3SourceMutex.Lock()
	ret, specificReturn := fake.createS3SourceReturnsOnCall[len(fake.createS3SourceArgsForCall)]
	fake.createS3SourceArgsForCall = append(fake.createS3SourceArgsForCall, struct {
		arg1 context.Context
		arg2 client.CreateS3SourceInput
	}{arg1, arg2})
	stub := fake.CreateS3SourceStub
	fakeReturns := fake.createS3SourceReturns
	fake.recordInvocation("CreateS3Source", []interface{}{arg1, arg2})
	fake.createS3SourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CreateS3SourceCallCount() int {
	fake.createS3SourceMutex.RLock()
	defer fake.createS3SourceMutex.RUnlock()
	return len(fake.createS3SourceArgsForCall)
}

func (fake *FakeClient) CreateS3SourceCalls(stub func(context.Context, client.CreateS3SourceInput) (client.CreateS3SourceOutput, error)) {
	fake.createS3SourceMutex.Lock()
	defer fake.createS3SourceMutex.Unlock()
	fake.CreateS3SourceStub = stub
}

func (fake *FakeClient) CreateS3SourceArgsForCall(i int) (context.Context, client.CreateS3SourceInput) {
	fake.createS3SourceMutex.RLock()
	defer fake.createS3SourceMutex.RUnlock()
	argsForCall := fake.createS3SourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) CreateS3SourceReturns(result1 client.CreateS3SourceOutput, result2 error) {
	fake.createS3SourceMutex.Lock()
	defer fake.createS3SourceMutex.Unlock()
	fake.CreateS3SourceStub = nil
	fake.createS3SourceReturns = struct {
		result1 client.CreateS3SourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CreateS3SourceReturnsOnCall(i int, result1 client.CreateS3SourceOutput, result2 error) {
	fake.createS3SourceMutex.Lock()
	defer fake.createS3SourceMutex.Unlock()
	fake.CreateS3SourceStub = nil
	if fake.createS3SourceReturnsOnCall == nil {
		fake.createS3SourceReturnsOnCall = make(map[int]struct {
			result1 client.CreateS3SourceOutput
			result2 error
		})
	}
	fake.createS3SourceReturnsOnCall[i] = struct {
		result1 client.CreateS3SourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteSource(arg1 context.Context, arg2 client.DeleteSourceInput) (client.DeleteSourceOutput, error) {
	fake.deleteSourceMutex.Lock()
	ret, specificReturn := fake.deleteSourceReturnsOnCall[len(fake.deleteSourceArgsForCall)]
	fake.deleteSourceArgsForCall = append(fake.deleteSourceArgsForCall, struct {
		arg1 context.Context
		arg2 client.DeleteSourceInput
	}{arg1, arg2})
	stub := fake.DeleteSourceStub
	fakeReturns := fake.deleteSourceReturns
	fake.recordInvocation("DeleteSource", []interface{}{arg1, arg2})
	fake.deleteSourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DeleteSourceCallCount() int {
	fake.deleteSourceMutex.RLock()
	defer fake.deleteSourceMutex.RUnlock()
	return len(fake.deleteSourceArgsForCall)
}

func (fake *FakeClient) DeleteSourceCalls(stub func(context.Context, client.DeleteSourceInput) (client.DeleteSourceOutput, error)) {
	fake.deleteSourceMutex.Lock()
	defer fake.deleteSourceMutex.Unlock()
	fake.DeleteSourceStub = stub
}

func (fake *FakeClient) DeleteSourceArgsForCall(i int) (context.Context, client.DeleteSourceInput) {
	fake.deleteSourceMutex.RLock()
	defer fake.deleteSourceMutex.RUnlock()
	argsForCall := fake.deleteSourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) DeleteSourceReturns(result1 client.DeleteSourceOutput, result2 error) {
	fake.deleteSourceMutex.Lock()
	defer fake.deleteSourceMutex.Unlock()
	fake.DeleteSourceStub = nil
	fake.deleteSourceReturns = struct {
		result1 client.DeleteSourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteSourceReturnsOnCall(i int, result1 client.DeleteSourceOutput, result2 error) {
	fake.deleteSourceMutex.Lock()
	defer fake.deleteSourceMutex.Unlock()
	fake.DeleteSourceStub = nil
	if fake.deleteSourceReturnsOnCall == nil {
		fake.deleteSourceReturnsOnCall = make(map[int]struct {
			result1 client.DeleteSourceOutput
			result2 error
		})
	}
	fake.deleteSourceReturnsOnCall[i] = struct {
		result1 client.DeleteSourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetS3Source(arg1 context.Context, arg2 string) (*client.S3LogIntegration, error) {
	fake.getS3SourceMutex.Lock()
	ret, specificReturn := fake.getS3SourceReturnsOnCall[len(fake.getS3SourceArgsForCall)]
	fake.getS3SourceArgsForCall = append(fake.getS3SourceArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetS3SourceStub
	fakeReturns := fake.getS3SourceReturns
	fake.recordInvocation("GetS3Source", []interface{}{arg1, arg2})
	fake.getS3SourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) GetS3SourceCallCount() int {
	fake.getS3SourceMutex.RLock()
	defer fake.getS3SourceMutex.RUnlock()
	return len(fake.getS3SourceArgsForCall)
}

func (fake *FakeClient) GetS3SourceCalls(stub func(context.Context, string) (*client.S3LogIntegration, error)) {
	fake.getS3SourceMutex.Lock()
	defer fake.getS3SourceMutex.Unlock()
	fake.GetS3SourceStub = stub
}

func (fake *FakeClient) GetS3SourceArgsForCall(i int) (context.Context, string) {
	fake.getS3SourceMutex.RLock()
	defer fake.getS3SourceMutex.RUnlock()
	argsForCall := fake.getS3SourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) GetS3SourceReturns(result1 *client.S3LogIntegration, result2 error) {
	fake.getS3SourceMutex.Lock()
	defer fake.getS3SourceMutex.Unlock()
	fake.GetS3SourceStub = nil
	fake.getS3SourceReturns = struct {
		result1 *client.S3LogIntegration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) GetS3SourceReturnsOnCall(i int, result1 *client.S3LogIntegration, result2 error) {
	fake.getS3SourceMutex.Lock()
	defer fake.getS3SourceMutex.Unlock()
	fake.GetS3SourceStub = nil
	if fake.getS3SourceReturnsOnCall == nil {
		fake.getS3SourceReturnsOnCall = make(map[int]struct {
			result1 *client.S3LogIntegration
			result2 error
		})
	}
	fake.getS3SourceReturnsOnCall[i] = struct {
		result1 *client.S3LogIntegration
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateS3Source(arg1 context.Context, arg2 client.UpdateS3SourceInput) (client.UpdateS3SourceOutput, error) {
	fake.updateS3SourceMutex.Lock()
	ret, specificReturn := fake.updateS3SourceReturnsOnCall[len(fake.updateS3SourceArgsForCall)]
	fake.updateS3SourceArgsForCall = append(fake.updateS3SourceArgsForCall, struct {
		arg1 context.Context
		arg2 client.UpdateS3SourceInput
	}{arg1, arg2})
	stub := fake.UpdateS3SourceStub
	fakeReturns := fake.updateS3SourceReturns
	fake.recordInvocation("UpdateS3Source", []interface{}{arg1, arg2})
	fake.updateS3SourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) UpdateS3SourceCallCount() int {
	fake.updateS3SourceMutex.RLock()
	defer fake.updateS3SourceMutex.RUnlock()
	return len(fake.updateS3SourceArgsForCall)
}

func (fake *FakeClient) UpdateS3SourceCalls(stub func(context.Context, client.UpdateS3SourceInput) (client.UpdateS3SourceOutput, error)) {
	fake.updateS3SourceMutex.Lock()
	defer fake.updateS3SourceMutex.Unlock()
	fake.UpdateS3SourceStub = stub
}

func (fake *FakeClient) UpdateS3SourceArgsForCall(i int) (context.Context, client.UpdateS3SourceInput) {
	fake.updateS3SourceMutex.RLock()
	defer fake.updateS3SourceMutex.RUnlock()
	argsForCall := fake.updateS3SourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) UpdateS3SourceReturns(result1 client.UpdateS3SourceOutput, result2 error) {
	fake.updateS3SourceMutex.Lock()
	defer fake.updateS3SourceMutex.Unlock()
	fake.UpdateS3SourceStub = nil
	fake.updateS3SourceReturns = struct {
		result1 client.UpdateS3SourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateS3SourceReturnsOnCall(i int, result1 client.UpdateS3SourceOutput, result2 error) {
	fake.updateS3SourceMutex.Lock()
	defer fake.updateS3SourceMutex.Unlock()
	fake.UpdateS3SourceStub = nil
	if fake.updateS3SourceReturnsOnCall == nil {
		fake.updateS3SourceReturnsOnCall = make(map[int]struct {
			result1 client.UpdateS3SourceOutput
			result2 error
		})
	}
	fake.updateS3SourceReturnsOnCall[i] = struct {
		result1 client.UpdateS3SourceOutput
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createS3SourceMutex.RLock()
	defer fake.createS3SourceMutex.RUnlock()
	fake.deleteSourceMutex.RLock()
	defer fake.deleteSourceMutex.RUnlock()
	fake.getS3SourceMutex.RLock()
	defer fake.getS3SourceMutex.RUnlock()
	fake.updateS3SourceMutex.RLock()
	defer fake.updateS3SourceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(FakeClient)
